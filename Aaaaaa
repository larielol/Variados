package main

import (
    "encoding/gob"
    "fmt"
    "log"
    "net"
    "sync"
)

type Server struct {
    mu          sync.RWMutex
    hashMap    map[int][]string
    clientData map[string][]int
}

func NewServer() *Server {
    return &Server{
        hashMap:    make(map[int][]string),
        clientData: make(map[string][]int),
    }
}

// Métodos thread-safe para o servidor
func (s *Server) handleStoreRequest(conn net.Conn, decoder *gob.Decoder) {
    var clientHashes []int
    if err := decoder.Decode(&clientHashes); err != nil {
        log.Println("Error decoding data:", err)
        return
    }

    clientIP := conn.RemoteAddr().String()
    
    s.mu.Lock()
    for _, hash := range clientHashes {
        // Adiciona ao hashMap
        if _, exists := s.hashMap[hash]; !exists {
            s.hashMap[hash] = []string{}
        }
        // Verifica se o IP já está na lista
        ipExists := false
        for _, ip := range s.hashMap[hash] {
            if ip == clientIP {
                ipExists = true
                break
            }
        }
        if !ipExists {
            s.hashMap[hash] = append(s.hashMap[hash], clientIP)
        }
        
        // Adiciona ao clientData
        hashExists := false
        for _, h := range s.clientData[clientIP] {
            if h == hash {
                hashExists = true
                break
            }
        }
        if !hashExists {
            s.clientData[clientIP] = append(s.clientData[clientIP], hash)
        }
    }
    s.mu.Unlock()

    printHashMap(s.hashMap)
}

func (s *Server) handleCreateRequest(conn net.Conn, decoder *gob.Decoder) {
    var fileHash int
    if err := decoder.Decode(&fileHash); err != nil {
        log.Println("Error decoding file hash:", err)
        return
    }

    clientIP := conn.RemoteAddr().String()

    s.mu.Lock()
    if _, exists := s.hashMap[fileHash]; !exists {
        s.hashMap[fileHash] = []string{}
    }
    
    // Verifica se o IP já está na lista
    ipExists := false
    for _, ip := range s.hashMap[fileHash] {
        if ip == clientIP {
            ipExists = true
            break
        }
    }
    if !ipExists {
        s.hashMap[fileHash] = append(s.hashMap[fileHash], clientIP)
    }
    
    // Verifica se o hash já está na lista do cliente
    hashExists := false
    for _, h := range s.clientData[clientIP] {
        if h == fileHash {
            hashExists = true
            break
        }
    }
    if !hashExists {
        s.clientData[clientIP] = append(s.clientData[clientIP], fileHash)
    }
    s.mu.Unlock()

    fmt.Printf("File created by %s: Hash %d\n", clientIP, fileHash)
}

func (s *Server) handleDeleteRequest(conn net.Conn, decoder *gob.Decoder) {
    var fileHash int
    if err := decoder.Decode(&fileHash); err != nil {
        log.Println("Error decoding file hash:", err)
        return
    }

    clientIP := conn.RemoteAddr().String()

    s.mu.Lock()
    // Remove do hashMap
    if ips, exists := s.hashMap[fileHash]; exists {
        for i, ip := range ips {
            if ip == clientIP {
                s.hashMap[fileHash] = append(ips[:i], ips[i+1:]...)
                break
            }
        }
        if len(s.hashMap[fileHash]) == 0 {
            delete(s.hashMap, fileHash)
        }
    }

    // Remove do clientData
    s.clientData[clientIP] = removeFromSlice(s.clientData[clientIP], fileHash)
    if len(s.clientData[clientIP]) == 0 {
        delete(s.clientData, clientIP)
    }
    s.mu.Unlock()

    fmt.Printf("File deleted by %s: Hash %d\n", clientIP, fileHash)
}

func (s *Server) handleQueryRequest(conn net.Conn, decoder *gob.Decoder) {
    var hash int
    if err := decoder.Decode(&hash); err != nil {
        log.Println("Error decoding hash:", err)
        return
    }

    s.mu.RLock()
    ips := make([]string, len(s.hashMap[hash]))
    copy(ips, s.hashMap[hash])
    s.mu.RUnlock()

    encoder := gob.NewEncoder(conn)
    encoder.Encode(ips)
}

func (s *Server) cleanupClientData(clientIP string) {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    hashes, exists := s.clientData[clientIP]
    if !exists {
        return
    }

    for _, hash := range hashes {
        ips := s.hashMap[hash]
        for i, ip := range ips {
            if ip == clientIP {
                s.hashMap[hash] = append(ips[:i], ips[i+1:]...)
                break
            }
        }

        if len(s.hashMap[hash]) == 0 {
            delete(s.hashMap, hash)
        }
    }

    delete(s.clientData, clientIP)
    log.Printf("Cleaned up data for client: %s\n", clientIP)
}
