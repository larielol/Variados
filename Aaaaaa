Perfeito, Lucas.
Vou pegar exatamente o seu código atual e transformá-lo na versão concorrente exigida pelo laboratório, obedecendo 100% ao que aparece nas imagens:

✅ usar várias threads
✅ classe de trabalho implementando Runnable
✅ divisão manual dos arquivos
✅ uso de start() e join()
✅ agregação segura dos resultados
✅ manter funções countInFile e countInSequence iguais
✅ substituir o laço for (File f : files) por execução paralela correta


---

✅ ✅ AQUI ESTÁ O CÓDIGO FINAL DO JEITO QUE O PROFESSOR QUER

Basta substituir o conteúdo do arquivo DnaConcurrentMain.java por este:

import java.io.File;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.FileReader;

public class DnaConcurrentMain {

    // Classe responsável por processar uma parte dos arquivos
    static class Worker implements Runnable {

        private final File[] files;
        private final String pattern;
        private long localCount = 0; // contador local da thread

        public Worker(File[] files, String pattern) {
            this.files = files;
            this.pattern = pattern;
        }

        // O que cada thread vai fazer
        @Override
        public void run() {
            try {
                for (File f : files) {
                    localCount += countInFile(f, pattern);
                }
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }

        public long getLocalCount() {
            return localCount;
        }
    }


    public static void main(String[] args) {

        if (args.length < 2) {
            System.err.println("Uso: java DnaConcurrentMain DIRETORIO_ARQUIVOS PADRAO");
            System.err.println("Exemplo: java DnaConcurrentMain dna_inputs CGTAA");
            System.exit(1);
        }

        String dirName = args[0];
        String pattern = args[1];

        File dir = new File(dirName);
        if (!dir.isDirectory()) {
            System.err.println("Caminho não é um diretório: " + dirName);
            System.exit(2);
        }

        File[] files = dir.listFiles((d, name) -> name.endsWith(".txt"));
        if (files == null || files.length == 0) {
            System.err.println("Nenhum arquivo .txt encontrado em: " + dirName);
            System.exit(3);
        }

        // Número de threads baseado nos núcleos da máquina
        int nThreads = Runtime.getRuntime().availableProcessors();

        // Criar arrays de threads e workers
        Thread[] threads = new Thread[nThreads];
        Worker[] workers = new Worker[nThreads];

        // Divisão dos arquivos por thread
        int chunk = (int) Math.ceil(files.length / (double) nThreads);

        for (int i = 0; i < nThreads; i++) {
            int start = i * chunk;
            int end = Math.min(start + chunk, files.length);

            File[] slice = new File[end - start];
            System.arraycopy(files, start, slice, 0, end - start);

            workers[i] = new Worker(slice, pattern);
            threads[i] = new Thread(workers[i]);
            threads[i].start(); // inicia a thread
        }

        // Aguardar todas as threads terminarem
        long total = 0;

        for (int i = 0; i < nThreads; i++) {
            try {
                threads[i].join(); // espera a thread i terminar
                total += workers[i].getLocalCount(); // soma resultados
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        System.out.println("Sequência " + pattern + " foi encontrada " + total + " vezes.");
    }


    // Mesma função do código serial
    public static long countInFile(File file, String pattern) throws IOException {
        long total = 0;
        try (BufferedReader br = new BufferedReader(new FileReader(file))) {
            String line;
            while ((line = br.readLine()) != null) {
                line = line.trim();
                if (!line.isEmpty()) {
                    total += countInSequence(line, pattern);
                }
            }
        }
        return total;
    }

    // Mesma função do código serial
    public static long countInSequence(String sequence, String pattern) {
        if (sequence == null || pattern == null) return 0;

        int n = sequence.length();
        int m = pattern.length();
        if (m == 0 || n < m) return 0;

        long count = 0;
        for (int i = 0; i <= n - m; i++) {
            if (sequence.regionMatches(false, i, pattern, 0, m)) {
                count++;
            }
        }
        return count;
    }

}


---

✅ O que foi modificado?

Parte	O que mudou?	Por quê?

Laço que processava todos os arquivos	Foi removido	Agora quem processa são as threads
Criada classe Worker implements Runnable	✅	Cada thread processa um pedaço da lista de arquivos
Thread.start() + Thread.join()	✅	Usado conforme exigido no PDF
Divisão manual do array de arquivos	✅	É o que o laboratório espera
Agregação dos resultados	✅	Soma do localCount de cada thread



---

✅ Seu código agora implementa CONCORRÊNCIA de verdade, exatamente como o enunciado exige.

Se quiser, posso:

✅ gerar comentários detalhados explicando cada parte para você colocar no relatório
✅ criar gráficos de speedup (serial × concorrente)
✅ ajudar a medir desempenho usando time e logs

Só pedir!
