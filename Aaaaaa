package main

import (
    "fmt"
    "math/rand"
    "sync"
    "time"
)

func produtor(id int, ch chan<- int, wg *sync.WaitGroup) {
    defer wg.Done()
    n := rand.Intn(5000) + 5000
    
    for i := 0; i < n; i++ {
        v := rand.Intn(100)
        ch <- v
    }
    fmt.Printf("Produtor %d finalizou após gerar %d valores\n", id, n)
}

func consumidor(id int, ch <-chan int, limite int, wg *sync.WaitGroup) {
    defer wg.Done()
    for v := range ch {
        if v > limite {
            fmt.Printf("Consumidor %d recebeu: %d\n", id, v)
        }
    }
}

func main() {
    rand.Seed(time.Now().UnixNano())
    ch := make(chan int, 100)
    limite := 50
    var prodWg, consWg sync.WaitGroup
    
    // Dois produtores
    for i := 1; i <= 2; i++ {
        prodWg.Add(1)
        go produtor(i, ch, &prodWg)
    }
    
    // Três consumidores
    for i := 1; i <= 3; i++ {
        consWg.Add(1)
        go consumidor(i, ch, limite, &consWg)
    }
    
    // Fecha canal após produtores terminarem
    go func() {
        prodWg.Wait()
        close(ch)
    }()
    
    // Aguarda consumidores terminarem
    consWg.Wait()
    fmt.Println("Processamento concluído por todos os consumidores")
}
